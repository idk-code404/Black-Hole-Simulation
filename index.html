<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Black Hole Simulator — Robust Loader</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:#06060a;color:#e6eef8}
    #app{display:flex;min-height:100vh;flex-direction:row}
    #canvas-wrap{flex:1;position:relative;overflow:hidden}
    canvas{display:block;width:100%;height:100%}
    /* Sidebar */
    #sidebar{width:360px;max-width:40vw;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));backdrop-filter:blur(6px);padding:18px;box-sizing:border-box;border-left:1px solid rgba(255,255,255,0.03)}
    #sidebar h1{font-size:18px;margin:6px 0 12px}
    .control-row{display:flex;align-items:center;gap:8px;margin:8px 0}
    label{font-size:13px;color:#cfe3ff;min-width:90px}
    input[type=range]{flex:1}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:#dfeeff;cursor:pointer}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.005));padding:12px;border-radius:8px;margin:10px 0}
    .small{font-size:13px;color:#bcd3ff}
    .footer{font-size:12px;color:#9fb8ff;margin-top:10px}
    #loaderMsg{position:absolute;left:12px;bottom:12px;color:#9fb8ff;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);z-index:20}
    /* Responsive */
    @media (max-width:900px){#sidebar{position:absolute;right:0;top:0;height:100vh;z-index:6;transform:translateX(0);max-width:95vw;width:320px}}    
  </style>
</head>
<body>
  <div id="app">
    <div id="canvas-wrap">
      <canvas id="three-canvas"></canvas>
      <canvas id="fallback-canvas" style="display:none;position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%"></canvas>
      <div id="hud" style="position:absolute;left:12px;top:12px;color:#dfeeff;z-index:5;font-size:13px;backdrop-filter:blur(4px);padding:8px;border-radius:8px;background:rgba(0,0,0,0.25);border:1px solid rgba(255,255,255,0.03)">
        <div id="info-line">Black Hole Simulator — WebGL / Three.js</div>
      </div>
      <div id="loaderMsg">Initializing…</div>
    </div>
    <aside id="sidebar">
      <h1>Black Hole Simulator</h1>
      <div class="panel">
        <div class="control-row">
          <label>Mass (M☉)</label>
          <input id="mass" type="range" min="1" max="100" step="1" value="10">
          <div class="small" id="mass-val">10</div>
        </div>
        <div class="control-row">
          <label>Spin (a)</label>
          <input id="spin" type="range" min="0" max="0.999" step="0.001" value="0.5">
          <div class="small" id="spin-val">0.500</div>
        </div>
        <div class="control-row">
          <label>Particles</label>
          <input id="particles" type="range" min="100" max="20000" step="100" value="3000">
          <div class="small" id="particles-val">3000</div>
        </div>
        <div class="control-row">
          <label>Physics</label>
          <select id="physics-mode">
            <option value="simple">Simplified</option>
            <option value="advanced">Advanced (relativistic)</option>
          </select>
        </div>
        <div class="control-row">
          <label>Lens</label>
          <input id="toggle-lens" type="checkbox" checked>
        </div>
        <div class="control-row">
          <label>Stylized Mode</label>
          <input id="stylized-mode" type="checkbox" checked>
        </div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="reset" class="btn">Reset</button>
          <button id="screenshot" class="btn">Screenshot</button>
        </div>
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Visualization</h3>
        <p class="small">Accretion disk uses a shader that supports a stylized mode (bright photon ring, stronger Doppler beaming, rim glow). Toggle <em>Stylized Mode</em> to exaggerate visibility for demos.</p>
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Educational Panels</h3>
        <div class="small"><strong>Event horizon:</strong> the boundary within which nothing, not even light, can escape.</div>
        <div class="small"><strong>Accretion disk:</strong> hot plasma orbiting the black hole; friction makes it glow.</div>
        <div class="small"><strong>Photon ring:</strong> the bright ring produced by light orbiting the black hole — emphasized in Stylized Mode.</div>
        <div class="small"><strong>Spin (a):</strong> dimensionless angular momentum; affects disk shape and ISCO.</div>
        <div class="small"><strong>Gravitational lensing:</strong> bending of light by the black hole's gravity.</div>
        <div class="small"><strong>Time dilation:</strong> close to the hole, time appears to slow to distant observers.</div>
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Tips</h3>
        <ol class="small">
          <li>Use <strong>Stylized Mode</strong> to make the black hole visually obvious for demos.</li>
          <li>Switch to <em>Advanced</em> physics for stronger time-dilation coloring (heavier GPU use).</li>
          <li>On low-end devices, toggle off <em>Lens</em> or reduce particles to improve performance.</li>
        </ol>
      </div>

      <div class="footer">Open-source educational demo • Works offline • Resize your window to test responsiveness</div>
    </aside>
  </div>

  <script>
  // Robust loader + fallback strategy
  (async function init(){
    // ---- utilities ----
    function loadScript(url){
      return new Promise((resolve,reject)=>{
        const s = document.createElement('script'); s.src = url; s.async = true; s.crossOrigin = 'anonymous';
        s.onload = ()=>resolve(url);
        s.onerror = ()=>reject(new Error('Failed to load: '+url));
        document.head.appendChild(s);
      });
    }

    async function tryLoadList(urls){
      let lastErr = null;
      for(const u of urls){
        try{ await loadScript(u); return u; }catch(e){ lastErr = e; console.warn('script load failed',u,e); }
      }
      throw lastErr || new Error('No URLs provided');
    }

    function supportsWebGL(){ try{const c=document.createElement('canvas'); return !!window.WebGLRenderingContext && (c.getContext('webgl')||c.getContext('experimental-webgl')); }catch(e){return false;} }

    // DOM refs and UI
    const canvas = document.getElementById('three-canvas');
    const fallbackCanvas = document.getElementById('fallback-canvas');
    const loaderMsg = document.getElementById('loaderMsg');
    const massSlider = document.getElementById('mass');
    const spinSlider = document.getElementById('spin');
    const particlesSlider = document.getElementById('particles');
    const physicsSelect = document.getElementById('physics-mode');
    const lensCheckbox = document.getElementById('toggle-lens');
    const stylizedCheckbox = document.getElementById('stylized-mode');
    const resetBtn = document.getElementById('reset');
    const screenshotBtn = document.getElementById('screenshot');
    const massVal = document.getElementById('mass-val');
    const spinVal = document.getElementById('spin-val');
    const particlesVal = document.getElementById('particles-val');

    const state = { mass: parseFloat(massSlider.value), spin: parseFloat(spinSlider.value), particles: parseInt(particlesSlider.value), physics: physicsSelect.value, lens: lensCheckbox.checked, stylized: stylizedCheckbox.checked };
    massVal.textContent = state.mass; spinVal.textContent = state.spin.toFixed(3); particlesVal.textContent = state.particles;

    // UI wrappers: safe calls to runtime functions
    massSlider.addEventListener('input', e=>{ state.mass = +e.target.value; massVal.textContent = state.mass; if(typeof window.updateBHParams==='function') try{ window.updateBHParams(); }catch(err){console.warn(err);} });
    spinSlider.addEventListener('input', e=>{ state.spin = +e.target.value; spinVal.textContent = state.spin.toFixed(3); if(typeof window.updateBHParams==='function') try{ window.updateBHParams(); }catch(err){console.warn(err);} });
    particlesSlider.addEventListener('input', e=>{ state.particles = +e.target.value; particlesVal.textContent = state.particles; if(typeof window.updateParticlesCount==='function') try{ window.updateParticlesCount(); }catch(err){console.warn(err);} });
    physicsSelect.addEventListener('change', e=>{ state.physics = e.target.value; if(typeof window.updatePhysicsMode==='function') try{ window.updatePhysicsMode(); }catch(err){console.warn(err);} });
    lensCheckbox.addEventListener('change', e=>{ state.lens = e.target.checked; if(typeof window.toggleLens==='function') try{ window.toggleLens(); }catch(err){console.warn(err);} });
    stylizedCheckbox.addEventListener('change', e=>{ state.stylized = e.target.checked; if(typeof window.setStylizedMode==='function') try{ window.setStylizedMode(state.stylized); }catch(err){console.warn(err);} });

    resetBtn.addEventListener('click', ()=>{ if(typeof window.resetScene==='function'){ try{ window.resetScene(); return; }catch(e){console.warn(e);} } massSlider.value=10; spinSlider.value=0.5; particlesSlider.value=3000; physicsSelect.value='simple'; lensCheckbox.checked=true; stylizedCheckbox.checked=true; massSlider.dispatchEvent(new Event('input')); spinSlider.dispatchEvent(new Event('input')); particlesSlider.dispatchEvent(new Event('input')); physicsSelect.dispatchEvent(new Event('change')); lensCheckbox.dispatchEvent(new Event('change')); stylizedCheckbox.dispatchEvent(new Event('change')); });

    screenshotBtn.addEventListener('click', ()=>{ if(typeof window.takeScreenshot==='function'){ try{ window.takeScreenshot(); return; }catch(e){console.warn(e);} } try{ if(fallbackCanvas && fallbackCanvas.toDataURL){ const url=fallbackCanvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='blackhole_screenshot.png'; a.click(); } else if(canvas && canvas.toDataURL){ const url=canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='blackhole_screenshot.png'; a.click(); } }catch(err){console.warn('screenshot fallback failed',err);} });

    // If no WebGL, run fallback
    if(!supportsWebGL()){ loaderMsg.textContent = 'WebGL not available — running 2D fallback.'; canvas.style.display='none'; fallbackCanvas.style.display='block'; runFallback2D(); return; }

    // Attempt to load Three.js (try UMD from multiple CDNs). If that fails, attempt module import. If still fails -> fallback 2D
    const threeUMD = [
      'https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.min.js',
      'https://unpkg.com/three@0.164.0/build/three.min.js'
    ];
    const controlsUMD = [
      'https://cdn.jsdelivr.net/npm/three@0.164.0/examples/js/controls/OrbitControls.js',
      'https://unpkg.com/three@0.164.0/examples/js/controls/OrbitControls.js'
    ];

    let THREElib = null;
    let OrbitControlsClass = null;

    try{
      loaderMsg.textContent = 'Loading Three.js (UMD)...';
      await tryLoadList(threeUMD);
      THREElib = window.THREE || null;
      if(!THREElib){
        // UMD script loaded but global not present — try module import
        console.warn('UMD loaded but window.THREE not found — trying module import');
        try{
          const mod = await import('https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js');
          THREElib = mod;
        }catch(e){ console.warn('Module import failed',e); }
      }
    }catch(errUMD){
      console.warn('UMD Three failed, trying module import',errUMD);
      try{
        loaderMsg.textContent = 'Loading Three.js (ESM)...';
        const mod = await import('https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js');
        THREElib = mod;
      }catch(errMod){
        console.error('Three.js load failed (UMD + ESM):',errUMD,errMod);
        loaderMsg.textContent = 'Failed to load WebGL renderer — running 2D fallback.';
        canvas.style.display='none'; fallbackCanvas.style.display='block'; runFallback2D(); return;
      }
    }

    // Attempt to load OrbitControls (UMD). If that fails, try ESM import. If that fails, create local lightweight controls.
    try{
      loaderMsg.textContent = 'Loading OrbitControls...';
      try{
        await tryLoadList(controlsUMD);
        // UMD OrbitControls should attach to global THREE
        if(window.THREE && window.THREE.OrbitControls) OrbitControlsClass = window.THREE.OrbitControls;
      }catch(e){
        // UMD failed -> try module
        try{
          const modCtrl = await import('https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/controls/OrbitControls.js');
          OrbitControlsClass = modCtrl.OrbitControls || null;
        }catch(e2){
          console.warn('OrbitControls module import failed',e2);
        }
      }
    }catch(e){ console.warn('OrbitControls load attempts failed',e); }

    // If THREElib is a module namespace (no global THREE), ensure references below use passed lib.
    // Run ThreeJS renderer with either global or module THREElib, and either OrbitControlsClass or a local fallback controls.
    try{
      loaderMsg.style.display = 'none';
      runThreeJS(THREElib, OrbitControlsClass);
    }catch(e){
      console.error('Failed to initialize Three.js scene:',e);
      loaderMsg.textContent = 'Failed to initialize WebGL scene — running 2D fallback.';
      canvas.style.display='none'; fallbackCanvas.style.display='block'; runFallback2D();
    }

    // --- runFallback2D ---
    function runFallback2D(){
      // simple 2D visualization
      const ctx = fallbackCanvas.getContext('2d');
      let w,h,center;
      function resize(){ w = fallbackCanvas.width = Math.max(1,fallbackCanvas.clientWidth || window.innerWidth); h = fallbackCanvas.height = Math.max(1,fallbackCanvas.clientHeight || window.innerHeight); center = {x:w/2,y:h/2}; }
      window.addEventListener('resize', resize); resize();
      let t=0;
      function draw(){ t+=0.01; ctx.fillStyle='rgba(0,0,6,1)'; ctx.fillRect(0,0,w,h); const R = Math.min(w,h)*0.08 * Math.sqrt(Math.max(1,state.mass)/10); ctx.beginPath(); ctx.arc(center.x,center.y,R,0,Math.PI*2); ctx.fillStyle='#000'; ctx.fill(); const grd = ctx.createRadialGradient(center.x,center.y,R*1.1, center.x,center.y, Math.min(w,h)); grd.addColorStop(0,'rgba(255,200,60,0.22)'); grd.addColorStop(0.4,'rgba(255,80,120,0.08)'); grd.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=grd; ctx.fillRect(0,0,w,h); const cnt=Math.min(200,Math.floor(state.particles/10)); for(let i=0;i<cnt;i++){ const ang=(t*0.2*(1+state.spin))+i*(Math.PI*2/cnt); const rad=R*1.5+(i%5)*6 + 40*Math.sin(t*0.5+i); const x=center.x+rad*Math.cos(ang); const y=center.y+(rad*0.36)*Math.sin(ang)*0.6; const depth=1/(1+rad*0.002); ctx.beginPath(); ctx.arc(x,y,Math.max(1,3*depth),0,Math.PI*2); ctx.fillStyle=`rgba(255,${120+Math.floor(100*depth)},${80},${0.8*depth})`; ctx.fill(); }
        requestAnimationFrame(draw);
      }
      draw();
      // expose reset/screenshot
      window.resetScene = ()=>{ massSlider.value=10; spinSlider.value=0.5; particlesSlider.value=3000; physicsSelect.value='simple'; lensCheckbox.checked=true; stylizedCheckbox.checked=true; massSlider.dispatchEvent(new Event('input')); spinSlider.dispatchEvent(new Event('input')); particlesSlider.dispatchEvent(new Event('input')); physicsSelect.dispatchEvent(new Event('change')); lensCheckbox.dispatchEvent(new Event('change')); stylizedCheckbox.dispatchEvent(new Event('change')); };
      window.takeScreenshot = ()=>{ try{ const url = fallbackCanvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='blackhole_screenshot.png'; a.click(); }catch(e){ console.warn(e); } };
      setTimeout(()=>{ console.info('Fallback mode active'); },300);
    }

    // --- runThreeJS ---
    function runThreeJS(THREElib, OrbitControlsClass){
      // Accept either global namespace (window.THREE) or module namespace.
      const THREE = THREElib;
      // Setup renderer, scene, camera similar to earlier code but using THREE variable
      const renderer = new THREE.WebGLRenderer({canvas:canvas,antialias:true,preserveDrawingBuffer:true});
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      const startW = Math.max(1, canvas.clientWidth || window.innerWidth);
      const startH = Math.max(1, canvas.clientHeight || window.innerHeight);
      renderer.setSize(startW, startH, false);
      const scene = new THREE.Scene(); scene.background = new THREE.Color(0x02020a);
      const camera = new THREE.PerspectiveCamera(50, startW/startH, 0.1, 2000); camera.position.set(0,28,90);

      // Controls: prefer provided OrbitControlsClass; otherwise create a lightweight custom control
      let controls;
      if(OrbitControlsClass){
        try{ controls = new OrbitControlsClass(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.08; }
        catch(e){ console.warn('OrbitControlsClass failed to instantiate', e); controls = createFallbackControls(THREE, camera, renderer.domElement); }
      } else if(typeof THREE.OrbitControls === 'function'){
        try{ controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.08; }catch(e){ console.warn('Global OrbitControls failed',e); controls = createFallbackControls(THREE, camera, renderer.domElement); }
      } else {
        controls = createFallbackControls(THREE, camera, renderer.domElement);
      }

      // Light + objects (keep stylized enhancements)
      scene.add(new THREE.AmbientLight(0xffffff,0.2)); const dir = new THREE.DirectionalLight(0xffffff,0.5); dir.position.set(10,20,10); scene.add(dir);
      const eventRadius = ()=>Math.max(1,state.mass*0.8);
      const bhGeo = new THREE.SphereGeometry(1,64,64); const bhMat = new THREE.MeshBasicMaterial({color:0x000000}); const bhMesh = new THREE.Mesh(bhGeo,bhMat); bhMesh.renderOrder = 2; scene.add(bhMesh);

      // Rim material
      const rimMat = new THREE.ShaderMaterial({ transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, uniforms:{ intensity:{value:1.8}, color:{value:new THREE.Color(0xffaa66)}, stylized:{value: state.stylized?1:0} }, vertexShader:`varying vec3 vNormal; void main(){ vNormal = normalMatrix * normal; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`, fragmentShader:`precision highp float; varying vec3 vNormal; uniform float intensity; uniform vec3 color; uniform float stylized; void main(){ float fres = pow(1.0 - abs(dot(normalize(vNormal), vec3(0.0,0.0,1.0))), 1.5); float rim = smoothstep(0.0,0.6, fres) * intensity * stylized; gl_FragColor = vec4(color * rim, rim); }` });
      const rimMesh = new THREE.Mesh(bhGeo, rimMat); rimMesh.scale.set(1.02,1.02,1.02); rimMesh.renderOrder = 3; scene.add(rimMesh);

      // Disk
      const diskGeo = new THREE.RingGeometry(1.6,6,512);
      const diskMat = new THREE.ShaderMaterial({ uniforms:{ time:{value:0}, spin:{value:state.spin}, mass:{value:state.mass}, resolution:{value:new THREE.Vector2(startW,startH)}, stylized:{value: state.stylized?1:0} }, vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`, fragmentShader:`precision highp float; varying vec2 vUv; uniform float time; uniform float spin; uniform float mass; uniform float stylized; void main(){ vec2 uv = vUv*2.0 - 1.0; float r = length(uv); float t = smoothstep(0.0,1.0,1.0 - r); float dop = 0.5 + 0.9*sin(uv.x*10.0 + time*2.0 + spin*8.0) * mix(0.5,1.2,stylized); vec3 cold = vec3(0.55,0.8,1.0); vec3 hot = vec3(1.0,0.45,0.12); vec3 color = mix(hot,cold,smoothstep(0.2,1.0,uv.x*0.5+0.5)); color = mix(vec3(0.02,0.01,0.05), color, pow(t,1.6)); color *= mix(1.0,2.4,stylized); float redshift = 1.0 - 0.25*smoothstep(0.0,1.0,r) * mix(1.0,0.5,stylized); color.r *= redshift; float alpha = smoothstep(0.99,0.25,r); gl_FragColor = vec4(color * (0.8 + 0.6 * dop), alpha * (0.6 + 0.4*stylized)); }`, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending });
      const diskMesh = new THREE.Mesh(diskGeo, diskMat); diskMesh.rotation.x = -Math.PI/2; diskMesh.scale.set(10,10,10); diskMesh.renderOrder = 1; scene.add(diskMesh);

      // Photon ring
      const ringGeo = new THREE.RingGeometry(0.99,1.12,256);
      const ringMat = new THREE.ShaderMaterial({ uniforms:{ intensity:{value:3.0}, color:{value:new THREE.Color(0xffcc66)}, stylized:{value: state.stylized?1:0} }, vertexShader:`varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`, fragmentShader:`precision highp float; varying vec2 vUv; uniform float intensity; uniform vec3 color; uniform float stylized; void main(){ vec2 c = vUv - vec2(0.5); float r = length(c)*2.0; float glow = smoothstep(0.6,0.48,r) - smoothstep(0.48,0.4,r); glow = pow(glow,0.8) * intensity * stylized; gl_FragColor = vec4(color * glow, glow); }`, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false });
      const photonRing = new THREE.Mesh(ringGeo, ringMat); photonRing.rotation.x = Math.PI/2; photonRing.renderOrder = 4; scene.add(photonRing);

      // Particles
      let particleSystem;
      function createParticles(count){ if(particleSystem) scene.remove(particleSystem); const geometry = new THREE.InstancedBufferGeometry(); const baseGeo = new THREE.PlaneGeometry(1,1); geometry.index = baseGeo.index; geometry.attributes.position = baseGeo.attributes.position; geometry.attributes.uv = baseGeo.attributes.uv; const offsets = new Float32Array(count*3); const scales = new Float32Array(count); const phases = new Float32Array(count); for(let i=0;i<count;i++){ const a = Math.random()*Math.PI*2; const rad = 12 + Math.random()*80; offsets[i*3+0] = Math.cos(a)*rad; offsets[i*3+1] = (Math.random()-0.5)*2.0; offsets[i*3+2] = Math.sin(a)*rad; scales[i] = 0.6 + Math.random()*2.5; phases[i] = Math.random()*Math.PI*2; } geometry.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets,3)); geometry.setAttribute('scale', new THREE.InstancedBufferAttribute(scales,1)); geometry.setAttribute('phase', new THREE.InstancedBufferAttribute(phases,1)); const particleMat = new THREE.ShaderMaterial({ uniforms:{time:{value:0}, mass:{value:state.mass}, spin:{value:state.spin}, physicsMode:{value: state.physics==='advanced'?1:0}, stylized:{value: state.stylized?1:0}}, vertexShader:`attribute vec3 offset; attribute float scale; attribute float phase; uniform float time; varying float vDepth; void main(){ vec3 pos = offset; float ang = time*0.2*(1.0+phase*0.1) + phase; float r = length(offset.xz); float omega = 1.0/(0.1 + pow(r*0.02,1.2)); float spinEffect = 1.0 + 0.6*mod(phase,1.0); float a = ang * omega * spinEffect; vec3 p = vec3(cos(a)*r, offset.y, sin(a)*r); vec4 mv = modelViewMatrix * vec4(p,1.0); vDepth = -mv.z; vec4 mvPosition = mv; mvPosition.xyz += position.xyz * scale * (1.0 + 0.3*clamp(1.0/r,0.0,1.0)); gl_Position = projectionMatrix * mvPosition; }`, fragmentShader:`precision highp float; varying float vDepth; uniform float time; uniform float mass; uniform float spin; uniform float physicsMode; uniform float stylized; void main(){ vec2 qq = gl_PointCoord - vec2(0.5); float d = length(qq); if(d>0.5) discard; float brightness = 1.2/(1.0 + vDepth*0.02); float tcol = physicsMode>0.5 ? clamp(1.0 - vDepth*0.004,0.2,1.0) : 1.0; vec3 base = vec3(1.0,0.78,0.4) * (1.0 + stylized*0.6); gl_FragColor = vec4(base*brightness*tcol, 1.0); }`, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending }); particleSystem = new THREE.Mesh(geometry, particleMat); particleSystem.frustumCulled = false; scene.add(particleSystem); }

      // Postprocessing setup
      const renderTarget = new THREE.WebGLRenderTarget(startW, startH);
      const fsQuadGeo = new THREE.PlaneGeometry(2,2);
      const lensMat = new THREE.ShaderMaterial({ uniforms:{tDiffuse:{value:null}, strength:{value:0.6}, center:{value:new THREE.Vector2(0.5,0.5)}, resolution:{value:new THREE.Vector2(startW,startH)}, stylized:{value: state.stylized?1:0}}, vertexShader:`void main(){ gl_Position = vec4(position,1.0); }`, fragmentShader:`precision highp float; uniform sampler2D tDiffuse; uniform float strength; uniform vec2 center; uniform vec2 resolution; uniform float stylized; void main(){ vec2 uv = gl_FragCoord.xy/resolution; vec2 p = (uv-center); float r = length(p); float theta = atan(p.y,p.x); float warp = 1.0 + strength * exp(-r*12.0) * (1.0 + 2.0*r) * (1.0 + 1.0*stylized); vec2 sampleUV = center + vec2(cos(theta), sin(theta)) * r * warp; vec4 col = texture2D(tDiffuse, sampleUV); float vign = smoothstep(0.9,0.35,r); if(stylized>0.5) col.rgb *= vec3(1.05,1.02,0.98); gl_FragColor = col * vign; }`, transparent:false });
      const fsQuad = new THREE.Mesh(fsQuadGeo, lensMat); const postScene = new THREE.Scene(); postScene.add(fsQuad); const postCamera = new THREE.Camera();

      // resize
      function onResize(){ const w = Math.max(1, canvas.clientWidth || window.innerWidth); const h = Math.max(1, canvas.clientHeight || window.innerHeight); renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); if(diskMat && diskMat.uniforms) diskMat.uniforms.resolution.value.set(w,h); if(lensMat && lensMat.uniforms) lensMat.uniforms.resolution.value.set(w,h); renderTarget.setSize(w,h); }
      window.addEventListener('resize', onResize); onResize();

      createParticles(state.particles);

      // update functions exposed for UI
      function updateBHParams(){ const r = eventRadius(); bhMesh.scale.set(r,r,r); rimMesh.scale.set(r*1.01,r*1.01,r*1.01); photonRing.scale.set(r*10,r*10,r*10); const scale = 1 + Math.log(state.mass+1); diskMesh.scale.set(10*scale,10*scale,10*scale); if(diskMat && diskMat.uniforms){ diskMat.uniforms.spin.value = state.spin; diskMat.uniforms.mass.value = state.mass; } if(particleSystem && particleSystem.material && particleSystem.material.uniforms){ particleSystem.material.uniforms.mass.value = state.mass; particleSystem.material.uniforms.spin.value = state.spin; } }
      function updateParticlesCount(){ createParticles(state.particles); }
      function updatePhysicsMode(){ if(particleSystem && particleSystem.material && particleSystem.material.uniforms) particleSystem.material.uniforms.physicsMode.value = state.physics==='advanced'?1:0; }
      function toggleLens(){ /* no-op: render loop checks state.lens */ }
      function setStylizedMode(enabled){ state.stylized = !!enabled; if(diskMat && diskMat.uniforms) diskMat.uniforms.stylized.value = state.stylized?1:0; if(rimMat && rimMat.uniforms) rimMat.uniforms.stylized.value = state.stylized?1:0; if(particleSystem && particleSystem.material && particleSystem.material.uniforms) particleSystem.material.uniforms.stylized.value = state.stylized?1:0; if(lensMat && lensMat.uniforms) lensMat.uniforms.stylized.value = state.stylized?1:0; if(photonRing && photonRing.material && photonRing.material.uniforms) photonRing.material.uniforms.stylized.value = state.stylized?1:0; }
      function resetSceneImpl(){ massSlider.value=10; spinSlider.value=0.5; particlesSlider.value=3000; physicsSelect.value='simple'; lensCheckbox.checked=true; stylizedCheckbox.checked=true; massSlider.dispatchEvent(new Event('input')); spinSlider.dispatchEvent(new Event('input')); particlesSlider.dispatchEvent(new Event('input')); physicsSelect.dispatchEvent(new Event('change')); lensCheckbox.dispatchEvent(new Event('change')); stylizedCheckbox.dispatchEvent(new Event('change')); state.mass = parseFloat(massSlider.value); state.spin = parseFloat(spinSlider.value); state.particles = parseInt(particlesSlider.value); state.physics = physicsSelect.value; state.lens = lensCheckbox.checked; state.stylized = stylizedCheckbox.checked; updateParticlesCount(); updateBHParams(); updatePhysicsMode(); setStylizedMode(state.stylized); }
      function takeScreenshotImpl(){ try{ if(renderer && renderer.domElement && renderer.domElement.toBlob){ renderer.domElement.toBlob(blob=>{ const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='blackhole_screenshot.png'; a.click(); URL.revokeObjectURL(url); }); } else if(fallbackCanvas && fallbackCanvas.toDataURL){ const url=fallbackCanvas.toDataURL(); const a=document.createElement('a'); a.href=url; a.download='blackhole_screenshot.png'; a.click(); } }catch(e){ console.warn('screenshot failed',e); } }

      // animation
      const clock = new THREE.Clock(); function animate(){ requestAnimationFrame(animate); const t = clock.getElapsedTime(); if(controls && typeof controls.update==='function') controls.update(); if(diskMat && diskMat.uniforms) diskMat.uniforms.time.value = t; if(particleSystem && particleSystem.material && particleSystem.material.uniforms) particleSystem.material.uniforms.time.value = t; renderer.setRenderTarget(renderTarget); renderer.render(scene,camera); renderer.setRenderTarget(null); if(state.lens){ lensMat.uniforms.tDiffuse.value = renderTarget.texture; renderer.render(postScene, postCamera); } else { renderer.render(scene,camera); } } animate();

      // expose
      window.updateBHParams = updateBHParams; window.updateParticlesCount = updateParticlesCount; window.updatePhysicsMode = updatePhysicsMode; window.toggleLens = toggleLens; window.resetScene = resetSceneImpl; window.takeScreenshot = takeScreenshotImpl; window.setStylizedMode = setStylizedMode;

      // initial
      updateBHParams(); setStylizedMode(state.stylized);
      setTimeout(()=>{ console.info('Three.js scene running — runtime functions exposed'); console.assert(typeof window.resetScene==='function'); console.assert(typeof window.updateBHParams==='function'); },500);

      // --- helper: fallback controls (simple orbital) ---
      function createFallbackControls(THREE, camera, dom){
        const target = new THREE.Vector3(0,0,0);
        let isDown=false, startX=0, startY=0;
        const spherical = { theta: Math.PI*0.5, phi: Math.PI*0.25, radius: camera.position.length() };
        function updateCamera(){ const r = spherical.radius; const x = r*Math.sin(spherical.phi)*Math.cos(spherical.theta); const y = r*Math.cos(spherical.phi); const z = r*Math.sin(spherical.phi)*Math.sin(spherical.theta); camera.position.set(x,y,z); camera.lookAt(target); }
        function onDown(e){ isDown=true; startX = e.clientX||e.touches[0].clientX; startY = e.clientY||e.touches[0].clientY; dom.style.cursor='grabbing'; }
        function onMove(e){ if(!isDown) return; const x = e.clientX||e.touches[0].clientX; const y = e.clientY||e.touches[0].clientY; const dx = (x-startX)*0.005; const dy = (y-startY)*0.005; startX = x; startY = y; spherical.theta -= dx; spherical.phi = Math.max(0.05, Math.min(Math.PI-0.05, spherical.phi - dy)); updateCamera(); }
        function onUp(){ isDown=false; dom.style.cursor='auto'; }
        function onWheel(e){ e.preventDefault(); spherical.radius = Math.max(10, Math.min(500, spherical.radius + e.deltaY*0.05)); updateCamera(); }
        dom.addEventListener('pointerdown', onDown); window.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp); dom.addEventListener('wheel', onWheel, {passive:false}); updateCamera(); return { update: function(){ /* nothing to do — camera updated via events */ } };
      }
    }
  })();
  </script>
</body>
</html>
